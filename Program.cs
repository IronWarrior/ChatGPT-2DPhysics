/******************************************************************************************************
 
The following code was generated by iteratively prompting ChatGPT.
Due to ChatGPT's output limit, the code was manually assembled here
by the prompter.

Two small pieces of code were were modified by the prompter, as follows:
    -The initial positions of the physics objects. The prompter could have requested ChatGPT
    to make these modifications, but it didn't seem necessary as it was clearly
    within ChatGPT's abilities.
    - Using the Console's background color to "color in" the pixels. This could have been
    done by asking ChatGPT, but the prompter forgot to make this request before ending the session >:(
    Both modifications are explicitly noted with the PROMPTER comment.

*******************************************************************************************************/
namespace PhysicsEngine
{
    class Program
    {
        static void Main(string[] args)
        {
            // Create a new instance of the physics engine
            PhysicsEngine engine = new PhysicsEngine(1, 1, 1);

            // Set up the initial state of the simulation
            engine.Setup();

            // Run the game loop
            while (true)
            {
                // Update the physics engine
                engine.Update(0.016666f);

                // Render the physics engine to the console
                engine.Render();

                // Pause for a brief period of time to slow down the game loop
                Thread.Sleep(17);
            }
        }
    }

    // Class representing a 2D vector
    public class Vector2
    {
        // Components of the vector
        public float x;
        public float y;

        // Constructor
        public Vector2(float x, float y)
        {
            this.x = x;
            this.y = y;
        }

        // Property to calculate the magnitude of the vector
        public float magnitude
        {
            get
            {
                return (float)Math.Sqrt(x * x + y * y);
            }
        }

        // Property to calculate the normalized version of the vector
        public Vector2 normalized
        {
            get
            {
                float magnitude = this.magnitude;
                return new Vector2(x / magnitude, y / magnitude);
            }
        }

        // Method to normalize the vector
        public void Normalize()
        {
            float magnitude = this.magnitude;
            x /= magnitude;
            y /= magnitude;
        }

        // Operator overloads for vector arithmetic
        public static Vector2 operator +(Vector2 a, Vector2 b)
        {
            return new Vector2(a.x + b.x, a.y + b.y);
        }

        public static Vector2 operator -(Vector2 a, Vector2 b)
        {
            return new Vector2(a.x - b.x, a.y - b.y);
        }

        public static Vector2 operator *(Vector2 a, float b)
        {
            return new Vector2(a.x * b, a.y * b);
        }

        public static Vector2 operator /(Vector2 a, float b)
        {
            return new Vector2(a.x / b, a.y / b);
        }

        public static Vector2 operator *(float a, Vector2 b)
        {
            return new Vector2(a * b.x, a * b.y);
        }

        public static Vector2 operator -(Vector2 a)
        {
            return new Vector2(-a.x, -a.y);
        }

        public static float Dot(Vector2 a, Vector2 b)
        {
            return a.x * b.x + a.y * b.y;
        }

        public static Vector2 Scale(Vector2 a, Vector2 b)
        {
            return new Vector2(a.x * b.x, a.y * b.y);
        }
    }

    // Class representing a physics object in the engine
    public class PhysicsObject
    {
        // Properties of the physics object
        public Vector2 position;
        public Vector2 velocity;
        public Vector2 acceleration;
        public float mass;
        public float radius;
        public ConsoleColor color; // NEW: property to store the object's color

        // Constructor for the physics object
        public PhysicsObject(Vector2 position, Vector2 velocity, Vector2 acceleration, float mass, float radius, ConsoleColor color)
        {
            this.position = position;
            this.velocity = velocity;
            this.acceleration = acceleration;
            this.mass = mass;
            this.radius = radius;
            this.color = color; // NEW: initialize the object's color
        }
    }

    // Class representing the 2D physics engine
    public class PhysicsEngine
    {
        // List of objects in the engine
        public List<PhysicsObject> objects;

        // Scale and offset values for rendering
        public float scale;
        public float offsetX;
        public float offsetY;

        // Constructor
        public PhysicsEngine(float scale, float offsetX, float offsetY)
        {
            objects = new List<PhysicsObject>();
            this.scale = scale;
            this.offsetX = offsetX;
            this.offsetY = offsetY;
        }

        // Method to set up the initial state of the simulation
        public void Setup()
        {
            // Create 10 objects with arbitrary radii, velocities, and masses
            // PROMPTER: Tweaked the various velocities, positions and scales to make for nice starting conditions.
            PhysicsObject obj1 = new PhysicsObject(new Vector2(5, 5), new Vector2(100, -100), new Vector2(0, 0), 3, 3, ConsoleColor.Red);
            PhysicsObject obj2 = new PhysicsObject(new Vector2(2, 2), new Vector2(-100, -100), new Vector2(0, 0), 3, 3, ConsoleColor.Blue);
            PhysicsObject obj3 = new PhysicsObject(new Vector2(4, 4), new Vector2(100, -100), new Vector2(0, 0), 3, 3, ConsoleColor.Cyan);
            PhysicsObject obj4 = new PhysicsObject(new Vector2(6, 6), new Vector2(-100, 100), new Vector2(0, 0), 2, 2, ConsoleColor.DarkBlue);
            PhysicsObject obj5 = new PhysicsObject(new Vector2(8, 8), new Vector2(100, -100), new Vector2(0, 0), 2, 2, ConsoleColor.Green);
            PhysicsObject obj6 = new PhysicsObject(new Vector2(10, 10), new Vector2(-100, 100), new Vector2(0, 0), 5, 5, ConsoleColor.Yellow);
            PhysicsObject obj7 = new PhysicsObject(new Vector2(12, 12), new Vector2(100, 100), new Vector2(0, 0), 2, 2, ConsoleColor.White);
            PhysicsObject obj8 = new PhysicsObject(new Vector2(14, 14), new Vector2(100, -100), new Vector2(0, 0), 2, 2, ConsoleColor.Magenta);
            PhysicsObject obj9 = new PhysicsObject(new Vector2(16, 16), new Vector2(100, -100), new Vector2(0, 0), 2, 2, ConsoleColor.DarkCyan);
            PhysicsObject obj10 = new PhysicsObject(new Vector2(18, 18), new Vector2(-100, -100), new Vector2(0, 0), 2, 2, ConsoleColor.DarkRed);

            // Add the objects to the list
            objects.Add(obj1);
            objects.Add(obj2);
            objects.Add(obj3);
            objects.Add(obj4);
            objects.Add(obj5);
            objects.Add(obj6);
            objects.Add(obj7);
            objects.Add(obj8);
            objects.Add(obj9);
            objects.Add(obj10);

            // Set other properties of the simulation, such as scale, offset, etc.
        }

        // Method to update the physics engine
        public void Update(float deltaTime)
        {
            // Loop over the objects in the simulation
            foreach (PhysicsObject obj in objects)
            {
                // Update the position and velocity of the object
                obj.position += obj.velocity * deltaTime;
                obj.velocity += obj.acceleration * deltaTime;

                // Check if the object is off the screen
                if (obj.position.x - obj.radius <= 0)
                {
                    // The object is off the left side of the screen, so move it back onto the screen
                    obj.position.x = obj.radius;
                }
                else if (obj.position.x + obj.radius >= Console.WindowWidth)
                {
                    // The object is off the right side of the screen, so move it back onto the screen
                    obj.position.x = Console.WindowWidth - obj.radius;
                }
                if (obj.position.y - obj.radius <= 0)
                {
                    // The object is off the top of the screen, so move it back onto the screen
                    obj.position.y = obj.radius;
                }
                else if (obj.position.y + obj.radius >= Console.WindowHeight)
                {
                    // The object is off the bottom of the screen, so move it back onto the screen
                    obj.position.y = Console.WindowHeight - obj.radius;
                }

                // Check if the object is colliding with any of the walls of the console
                if (obj.position.x - obj.radius <= 0 || obj.position.x + obj.radius >= Console.WindowWidth)
                {
                    // The object is colliding with a horizontal wall, so reverse its x velocity
                    obj.velocity.x = -obj.velocity.x;
                }
                if (obj.position.y - obj.radius <= 0 || obj.position.y + obj.radius >= Console.WindowHeight)
                {
                    // The object is colliding with a vertical wall, so reverse its y velocity
                    obj.velocity.y = -obj.velocity.y;
                }
            }

            // Loop over the objects in the simulation
            for (int i = 0; i < objects.Count; i++)
            {
                // Get the first object
                PhysicsObject obj1 = objects[i];

                // Loop over the other objects in the simulation
                for (int j = i + 1; j < objects.Count; j++)
                {
                    // Get the second object
                    PhysicsObject obj2 = objects[j];

                    // Calculate the distance between the objects
                    Vector2 delta = obj1.position - obj2.position;
                    float distance = delta.magnitude;

                    // Check if the objects are colliding
                    if (distance < obj1.radius + obj2.radius)
                    {
                        // Calculate the normal and tangent vectors of the collision
                        Vector2 normal = delta / distance;
                        Vector2 tangent = new Vector2(-normal.y, normal.x);

                        // Calculate the velocities of the objects in the normal and tangent directions
                        float velNormal1 = Vector2.Dot(obj1.velocity, normal);
                        float velTangent1 = Vector2.Dot(obj1.velocity, tangent);
                        float velNormal2 = Vector2.Dot(obj2.velocity, normal);
                        float velTangent2 = Vector2.Dot(obj2.velocity, tangent);

                        // Calculate the new velocities of the objects in the normal direction
                        float newVelNormal1 = (velNormal1 * (obj1.mass - obj2.mass) + 2 * obj2.mass * velNormal2) / (obj1.mass + obj2.mass);
                        float newVelNormal2 = (velNormal2 * (obj2.mass - obj1.mass) + 2 * obj1.mass * velNormal1) / (obj1.mass + obj2.mass);

                        // Update the velocities of the objects
                        obj1.velocity = newVelNormal1 * normal + velTangent1 * tangent;
                        obj2.velocity = newVelNormal2 * normal + velTangent2 * tangent;

                        // Displace the objects so that they are not overlapping
                        obj1.position = obj1.position + normal * (obj1.radius + obj2.radius - distance) / 2;
                        obj2.position = obj2.position - normal * (obj1.radius + obj2.radius - distance) / 2;
                    }
                }

                // Update the position, velocity and acceleration of the object
                obj1.position += obj1.velocity * deltaTime;
                obj1.velocity += obj1.acceleration * deltaTime;
            }
        }

        // Method to render the physics engine
        public void Render()
        {
            // Set the background color to a dark grey
            Console.BackgroundColor = ConsoleColor.DarkGray;

            // Clear the console
            Console.Clear();

            // Loop over the objects in the simulation
            foreach (PhysicsObject obj in objects)
            {
                // Calculate the scaled position of the object
                Vector2 scaledPos = obj.position * scale;

                // Loop over the rows and columns of the object
                for (int i = (int)-obj.radius; i <= (int)obj.radius; i++)
                {
                    for (int j = (int)-obj.radius; j <= (int)obj.radius; j++)
                    {
                        // Check if the pixel is within a circle centered at the object's position
                        if (i * i + j * j <= obj.radius * obj.radius)
                        {
                            // The pixel is within the circle, so calculate its position
                            int x = (int)scaledPos.x + j;
                            int y = (int)scaledPos.y + i;

                            // Check if the pixel is within the bounds of the console
                            if (x >= 0 && x < Console.WindowWidth && y >= 0 && y < Console.WindowHeight)
                            {
                                // The pixel is within the bounds of the console, so set its color
                                Console.SetCursorPosition(x, y);
                                Console.ForegroundColor = obj.color;
                                // PROMPTER: Also set the background color to "color in" the square "pixels" of the console.
                                Console.BackgroundColor = obj.color;
                                Console.Write("O");
                            }
                        }
                    }
                }
            }
        }
    }
}


